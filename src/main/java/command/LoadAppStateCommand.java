package command;

import controller.Context;
import model.*;
import view.IView;

import java.awt.print.Book;
import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class LoadAppStateCommand implements ICommand<Boolean> {
    private Boolean successResult;
    private final String fileName;

    public LoadAppStateCommand(String fileName) {
        this.fileName = fileName;
    }

    /**
     * @param context object that provides access to global application state
     * @param view    allows passing information to the user interface
     * @verifies.that the current user is logged in
     */
    @Override
    public void execute(Context context, IView view) {
        // Check Staff Logged In
        User currentUser = context.getUserState().getCurrentUser();
        if (!(currentUser instanceof Staff)) {
            view.displayFailure("LoadAppStateCommand",
                    LogStatus.LOAD_APP_STAFF_NOT_LOGGED_IN,
                    Map.of("currentUser", currentUser != null ? currentUser : "none"));
            successResult = false;
            return;
        }

        // Attempt to deserialise given file
        FileInputStream fis = null;
        ObjectInputStream in = null;
        Context savedContext = null;
        try {
            fis = new FileInputStream(fileName);
            in = new ObjectInputStream(fis);
            savedContext = (Context) in.readObject();
            in.close();
        } catch (IOException | ClassNotFoundException e) {
            // When file is not found
            view.displayFailure("LoadAppStateCommand",
                    LogStatus.LOAD_APP_INVALID_FILE_PROVIDED,
                    Map.of("filename", fileName));
            successResult = false;
            return;
        }

        /*
         * The following data structures are used to store any data which is required to
         * facilitate the merge of the saved
         * state into the active state provided there are no clashes. This includes:
         * - New objects to be added
         * - Mappings from saved objects to active objects that are the same (which will
         * be used to update loaded bookings)
         * To check for object equality - we override .equals() so we do not check based
         * on hashcode or objectNumber which
         * could be different
         */

        // Event Tags
        Map<String, EventTag> newEventTags = new HashMap<>();

        // We store a mapping between identical consumers in the saved and active state
        // Also store all new users
        Map<Consumer, Consumer> savedToActiveConsumerMap = new HashMap<>();
        ArrayList<Consumer> newConsumers = new ArrayList<>();
        ArrayList<Staff> newStaff = new ArrayList<>();

        // We store a mapping between identical events in the saved and active state
        Map<Event, Event> savedToActiveEventMap = new HashMap<>();
        ArrayList<Event> newEvents = new ArrayList<>();

        // New bookings
        ArrayList<Booking> newBookings = new ArrayList<>();

        // Check For Clashing Tags
        for (String savedTagName : savedContext.getEventState().getPossibleTag().keySet()) {
            if (context.getEventState().getPossibleTag().containsKey(savedTagName)) {
                // Check values are the same
                EventTag activeTag = context.getEventState().getPossibleTag().get(savedTagName);
                EventTag savedTag = savedContext.getEventState().getPossibleTag().get(savedTagName);
                if (!activeTag.equals(savedTag)) {
                    view.displayFailure("LoadAppStateCommand",
                            LogStatus.LOAD_APP_CLASHING_TAGS,
                            Map.of("tag name", savedTagName));
                    successResult = false;
                    return;
                }
            } else { // Otherwise, we have a new event tag
                newEventTags.put(savedTagName, savedContext.getEventState().getPossibleTag().get(savedTagName));
            }
        }

        /*
         * README
         * When checking for clashing users - I do not check based on passwords. This is
         * because an equivalent password
         * will have two different hashes generated by BCrypt. This means we would
         * always get clashes when a user exists
         * in both the active and saved state
         */

        // Check For Clashing Emails
        for (String savedUserEmail : savedContext.getUserState().getAllUsers().keySet()) {
            // Check if a staff email
            if (!(savedContext.getUserState().getAllUsers().get(savedUserEmail) instanceof Staff)) {
                // If not, must be a consumer
                Consumer savedConsumer = (Consumer) savedContext.getUserState().getAllUsers().get(savedUserEmail);
                if (context.getUserState().getAllUsers().containsKey(savedUserEmail)) {
                    Consumer activeConsumer = (Consumer) context.getUserState().getAllUsers().get(savedUserEmail);
                    // Check consumer with the same email is equal and has consistent preferences
                    if (!(activeConsumer.equals(savedConsumer))) {
                        view.displayFailure("LoadAppStateCommand",
                                LogStatus.LOAD_APP_CLASHING_USERS,
                                Map.of("email", savedUserEmail));
                        successResult = false;
                        return;
                    } else { // This consumer already exists in the active state but could have some new
                             // bookings so we create a mapping between them
                        savedToActiveConsumerMap.put(savedConsumer, activeConsumer);
                    }
                } else {
                    newConsumers.add(savedConsumer);
                }
            } else { // Otherwise, this is a staff member. Check the email does not already exist
                if (!context.getUserState().getAllUsers().containsKey(savedUserEmail)) {
                    Staff newStaffMember = (Staff) savedContext.getUserState().getAllUsers().get(savedUserEmail);
                    newStaff.add(newStaffMember);
                }
            }
        }

        // Check For Clashing Events
        for (Event savedEvent : savedContext.getEventState().getAllEvents()) {
            // Assume it is a new event, find if it is not
            boolean eventExists = false;
            for (Event activeEvent : context.getEventState().getAllEvents()) {
                if (savedEvent.getTitle().equals(activeEvent.getTitle()) &&
                        savedEvent.getStartDateTime().equals(activeEvent.getStartDateTime()) &&
                        savedEvent.getEndDateTime().equals(activeEvent.getEndDateTime())) {
                    if (!savedEvent.equals(activeEvent)) {
                        view.displayFailure("LoadAppStateCommand", LogStatus.LOAD_APP_CLASHING_EVENTS);
                        successResult = false;
                        return;
                    }
                    // Otherwise - this is the case where we have an event that exists in both
                    // active and saved context - need to store a mapping
                    savedToActiveEventMap.put(savedEvent, activeEvent);
                    eventExists = true;
                }
            }
            if (!eventExists) {
                newEvents.add(savedEvent);
            }
        }

        /*
         * README
         * For bookings, we allow for:
         * - Consumers which exist in the active state to have bookings for new events
         * in the saved state
         * - New consumers in the saved state to have bookings for new events in the
         * saved state
         * We check that the following is consistent:
         * - For consumers that exist in the active and saved state who have bookings to
         * events which exist in the active
         * and saved state, we check ensure these bookings are consistent
         * Finally, we do not allow for:
         * - New consumers in the saved state to have bookings for events in the active
         * state which is not already acknowledged
         * by the active state (An event may not have enough tickets to accommodate
         * merging bookings from the saved state
         * and the active state made by different consumers). This would not be caught
         * by checking for identical bookings
         */

        // Check For Clashing Bookings
        for (Booking savedBooking : savedContext.getBookingState().getBookings()) {
            if (newConsumers.contains(savedBooking.getBooker())) { // New consumer
                // This is the case where a new consumer has a booking for an existing event
                // We do not allow this because the existing event may not have enough tickets
                // to accommodate this merge
                if (savedToActiveEventMap.containsKey(savedBooking.getEvent())) {
                    view.displayFailure("LoadAppStateCommand",
                            LogStatus.LOAD_APP_CLASHING_BOOKINGS);
                    successResult = false;
                    return;
                } else {// Otherwise, we have a new consumer with a booking for a new event which is
                        // fine
                    newBookings.add(savedBooking);
                }
            } else { // Existing Consumer
                if (savedToActiveEventMap.containsKey(savedBooking.getEvent())) { // Old event
                    // Existing consumer with a booking for an existing event, need to check it is
                    // consistent with a booking in the active state
                    for (Booking activeBooking : context.getBookingState().getBookings()) {
                        if (savedBooking.getEvent().equals(activeBooking.getEvent()) &&
                                savedBooking.getBooker().equals(activeBooking.getBooker()) &&
                                savedBooking.getBookingDateTime().equals(activeBooking.getBookingDateTime())) {
                            if (!savedBooking.equals(activeBooking)) {
                                view.displayFailure("LoadAppStateCommand",
                                        LogStatus.LOAD_APP_CLASHING_BOOKINGS);
                                successResult = false;
                                return;
                            }
                        }
                    }
                } else { // Old consumer with a booking for a new event which is fine
                    newBookings.add(savedBooking);
                }
            }
        }

        // If this point has been reached, we have found no clashes and may merge the
        // loaded state into the active state

        // Merge the event tags
        for (String newEventTagName : newEventTags.keySet()) {
            context.getEventState().addEventTag(newEventTagName, newEventTags.get(newEventTagName));
        }

        /*
         * Since we cannot change the event number (it is final), we create new events
         * for the loaded new events
         * This mapping connects a loaded new event to the created event which is equal
         * to it but has a renumbered event number
         */
        Map<Event, Event> loadedToMergedEventMap = new HashMap<>();

        // Merge new events and create mapping from old version to new version
        for (Event loadedNewEvent : newEvents) {
            // Merge into active state
            Event mergedNewEvent = context.getEventState().addEvent(loadedNewEvent);
            // Store mapping so bookings may be updated
            loadedToMergedEventMap.put(loadedNewEvent, mergedNewEvent);
        }

        // For existing consumers with bookings to new events
        for (Consumer savedExistingUser : savedToActiveConsumerMap.keySet()) {
            for (Booking newBooking : newBookings) {
                if (newBooking.getBooker().equals(savedExistingUser)) {
                    // Add this booking to the active state
                    Consumer activeExistingUser = savedToActiveConsumerMap.get(savedExistingUser);
                    Event newEvent = loadedToMergedEventMap.get(newBooking.getEvent());
                    Booking addedBooking = context.getBookingState().createBooking(activeExistingUser, newEvent,
                            newBooking.getNumTickets());
                    activeExistingUser.getBookings().add(addedBooking);
                }
            }
        }

        // For new consumers with bookings to new events
        for (Consumer newConsumer : newConsumers) {
            for (Booking newConsumersBooking : newConsumer.getBookings()) {
                Event newEvent = loadedToMergedEventMap.get(newConsumersBooking.getEvent());
                newConsumersBooking = context.getBookingState().createBooking(newConsumer, newEvent,
                        newConsumersBooking.getNumTickets());
            }
            context.getUserState().addUser(newConsumer);
        }

        // Add new staff as well
        for (Staff staff : newStaff) {
            context.getUserState().addUser(staff);
        }

        successResult = true;
        view.displaySuccess(
                "LoadAppStateCommand",
                LogStatus.LOAD_APP_STATE_SUCCESS,
                Map.of("filename", fileName));
    }

    /**
     * @return True if successful and false otherwise
     */
    @Override
    public Boolean getResult() {
        return successResult;
    }

    private enum LogStatus {
        LOAD_APP_STAFF_NOT_LOGGED_IN,
        LOAD_APP_INVALID_FILE_PROVIDED,
        LOAD_APP_CLASHING_TAGS,
        LOAD_APP_CLASHING_USERS,
        LOAD_APP_CLASHING_EVENTS,
        LOAD_APP_CLASHING_BOOKINGS,
        LOAD_APP_STATE_SUCCESS
    }
}